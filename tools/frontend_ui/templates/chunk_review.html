{% extends "base.html" %}

{% block title %}Content Dashboard{% endblock %}

{% block head %}
<style>
    .loading { display: none; }
    .loading.active { display: block; }
    .error { color: #dc3545; }
    .success { color: #28a745; }
    .clickable-filter { cursor: pointer; transition: background-color 0.2s; }
    .clickable-filter:hover { background-color: #f8f9fa; }
    .clickable-filter.active { background-color: #007bff; color: white; }
    .search-status { margin-top: 8px; padding: 4px 8px; background-color: #e3f2fd; border-left: 3px solid #2196f3; }
    .relevance-score { color: #2196f3; font-weight: bold; }
    .search-indicator { color: #2196f3; font-size: 14px; }
    #clearSearch { margin-left: 5px; }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="dashboard-header">
        <h2>Content Dashboard</h2>
        <div class="stats-panel" id="statsPanel">
            <div class="stat-item clickable-filter" data-filter="pending">
                <span class="stat-label">Pending:</span>
                <span class="stat-value" id="pendingCount">-</span>
            </div>
            <div class="stat-item clickable-filter" data-filter="approved">
                <span class="stat-label">Approved:</span>
                <span class="stat-value" id="approvedCount">-</span>
            </div>
            <div class="stat-item clickable-filter" data-filter="rejected">
                <span class="stat-label">Rejected:</span>
                <span class="stat-value" id="rejectedCount">-</span>
            </div>
            <div class="stat-item clickable-filter" data-filter="global">
                <span class="stat-label">Global:</span>
                <span class="stat-value" id="globalCount">-</span>
            </div>
            <div class="stat-item" data-filter="all">
                <span class="stat-label">Total:</span>
                <span class="stat-value" id="totalCount">-</span>
            </div>
        </div>
        <div class="controls">
            <button id="refreshData" class="btn btn-primary">Refresh Data</button>
            <button id="loadMoreChunks" class="btn btn-secondary">Load More</button>
        </div>
    </div>

    <div class="main-workspace">
        <!-- Chunk Display Area -->
        <section class="chunk-display">
            <div class="chunk-header">
                <h3>Content List</h3>
                <div class="chunk-controls">
                    <button id="selectAllChunks" class="btn btn-sm btn-outline">Select All</button>
                    <button id="clearSelection" class="btn btn-sm btn-outline">Clear Selection</button>
                </div>
            </div>
            
            <div class="chunk-list" id="chunkList">
                <div class="loading" id="loadingChunks">
                    <p>Loading chunks...</p>
                </div>
                <div class="no-chunks" id="noChunks" style="display: none;">
                    <p>No pending chunks found.</p>
                </div>
            </div>
        </section>

        <!-- Control Panel -->
        <aside class="control-panel">
            <div class="panel-section">
                <h3>Bulk Actions</h3>
                <div class="action-buttons">
                    <button id="approveSelected" class="btn btn-success" disabled>
                        Approve Selected (<span id="selectedCount">0</span>)
                    </button>
                    <button id="pendingSelected" class="btn btn-warning" disabled>
                        Set to Pending
                    </button>
                    <button id="rejectSelected" class="btn btn-danger" disabled>
                        Reject Selected
                    </button>
                    <button id="promoteSelected" class="btn btn-primary" disabled>
                        Promote to Global
                    </button>
                    <button id="demoteSelected" class="btn btn-secondary" disabled>
                        Demote to Project
                    </button>
                </div>
            </div>

            <div class="panel-section rejection-panel" id="rejectionPanel" style="display: none;">
                <h4>Rejection Reason</h4>
                <textarea id="rejectionReason" placeholder="Enter reason for rejection..." rows="3"></textarea>
                <div class="rejection-actions">
                    <button id="confirmReject" class="btn btn-danger">Confirm Rejection</button>
                    <button id="cancelReject" class="btn btn-secondary">Cancel</button>
                </div>
            </div>

            <div class="panel-section promotion-panel" id="promotionPanel" style="display: none;">
                <h4>Promotion Justification</h4>
                <textarea id="promotionJustification" placeholder="Enter justification for promoting to Global realm..." rows="3"></textarea>
                <div class="promotion-actions">
                    <button id="confirmPromote" class="btn btn-primary">Confirm Promotion</button>
                    <button id="cancelPromote" class="btn btn-secondary">Cancel</button>
                </div>
            </div>

            <div class="panel-section demotion-panel" id="demotionPanel" style="display: none;">
                <h4>Demotion Justification</h4>
                <textarea id="demotionJustification" placeholder="Enter justification for demoting to Project realm..." rows="3"></textarea>
                <div class="demotion-actions">
                    <button id="confirmDemote" class="btn btn-secondary">Confirm Demotion</button>
                    <button id="cancelDemote" class="btn btn-secondary">Cancel</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>Content Search</h3>
                <div class="search-controls">
                    <div class="search-input-group">
                        <input type="text" id="searchQuery" placeholder="Search content..." class="form-control">
                        <select id="searchType" class="form-control search-type-select">
                            <option value="simulate">Agent Simulation</option>
                            <option value="hybrid">Hybrid Search</option>
                            <option value="semantic">Semantic Search</option>
                            <option value="keyword">Keyword Search</option>
                        </select>
                    </div>
                    <button id="performSearch" class="btn btn-primary">Search</button>
                    <button id="clearSearch" class="btn btn-secondary" style="display: none;">Clear</button>
                </div>
                <div class="search-status" id="searchStatus" style="display: none;">
                    <small class="text-muted">Showing search results for: <span id="currentSearchQuery"></span></small>
                </div>
            </div>

            <div class="panel-section">
                <h3>Recent Activity</h3>
                <div class="recent-activity" id="recentActivity">
                    <p>Loading recent activity...</p>
                </div>
            </div>
        </aside>
    </div>
</div>

<!-- Modal for Chunk Details -->
<div class="modal" id="chunkModal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Chunk Details</h3>
            <button class="modal-close" id="closeModal">&times;</button>
        </div>
        <div class="modal-body" id="modalBody">
            <!-- Chunk details will be populated here -->
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Main application class
    class ChunkReviewApp {
        constructor() {
            this.selectedChunks = new Set();
            this.currentChunks = [];
            this.currentPage = 1;
            this.pageSize = 20;
            this.currentFilter = 'pending'; // Default filter
            this.isSearchMode = false; // Track if we're in search mode
            this.currentSearchQuery = '';
            this.currentSearchType = 'simulate';
            
            this.initializeApp();
        }
        
        async initializeApp() {
            this.bindEvents();
            await this.loadInitialData();
            this.startPeriodicRefresh();
        }
        
        bindEvents() {
            // Refresh controls
            document.getElementById('refreshData').addEventListener('click', () => this.refreshData());
            document.getElementById('loadMoreChunks').addEventListener('click', () => this.loadMoreChunks());
            
            // Filter controls
            document.querySelectorAll('.clickable-filter').forEach(filter => {
                filter.addEventListener('click', (e) => this.applyFilter(e.currentTarget.dataset.filter));
            });
            
            // Selection controls
            document.getElementById('selectAllChunks').addEventListener('click', () => this.selectAllChunks());
            document.getElementById('clearSelection').addEventListener('click', () => this.clearSelection());
            
            // Approval actions
            document.getElementById('approveSelected').addEventListener('click', () => this.approveSelected());
            document.getElementById('pendingSelected').addEventListener('click', () => this.pendingSelected());
            document.getElementById('rejectSelected').addEventListener('click', () => this.showRejectionPanel());
            document.getElementById('promoteSelected').addEventListener('click', () => this.showPromotionPanel());
            document.getElementById('demoteSelected').addEventListener('click', () => this.showDemotionPanel());
            
            // Rejection panel
            document.getElementById('confirmReject').addEventListener('click', () => this.confirmReject());
            document.getElementById('cancelReject').addEventListener('click', () => this.hideRejectionPanel());
            
            // Promotion panel
            document.getElementById('confirmPromote').addEventListener('click', () => this.confirmPromote());
            document.getElementById('cancelPromote').addEventListener('click', () => this.hidePromotionPanel());
            
            // Demotion panel
            document.getElementById('confirmDemote').addEventListener('click', () => this.confirmDemote());
            document.getElementById('cancelDemote').addEventListener('click', () => this.hideDemotionPanel());
            
            // Content search
            document.getElementById('performSearch').addEventListener('click', () => this.performSearch());
            document.getElementById('clearSearch').addEventListener('click', () => this.clearSearch());
            document.getElementById('searchQuery').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.performSearch();
            });
            
            // Modal controls
            document.getElementById('closeModal').addEventListener('click', () => this.closeModal());
        }
        
        async loadInitialData() {
            await Promise.all([
                this.loadStats(),
                this.loadChunks(),
                this.loadRecentActivity()
            ]);
            
            // Set initial filter to pending
            this.applyFilter('pending');
        }
        
        async loadStats() {
            try {
                const response = await Utils.makeRequest('/api/chunks/stats');
                this.updateStats(response);
            } catch (error) {
                console.error('Failed to load stats:', error);
                Utils.showNotification('Failed to load statistics', 'error');
            }
        }
        
        updateStats(stats) {
            document.getElementById('pendingCount').textContent = Utils.formatNumber(stats.pending);
            document.getElementById('approvedCount').textContent = Utils.formatNumber(stats.approved);
            document.getElementById('rejectedCount').textContent = Utils.formatNumber(stats.rejected);
            document.getElementById('globalCount').textContent = Utils.formatNumber(stats.global || 0);
            document.getElementById('totalCount').textContent = Utils.formatNumber(stats.total);
        }
        
        async loadChunks(reset = true) {
            if (reset) {
                this.currentChunks = [];
                this.currentPage = 1;
            }
            
            const loadingElement = document.getElementById('loadingChunks');
            loadingElement.classList.add('active');
            
            try {
                let endpoint;
                switch(this.currentFilter) {
                    case 'pending':
                        endpoint = `/api/chunks/pending?limit=${this.pageSize}`;
                        break;
                    case 'approved':
                        endpoint = `/api/chunks/approved?limit=${this.pageSize}`;
                        break;
                    case 'rejected':
                        endpoint = `/api/chunks/rejected?limit=${this.pageSize}`;
                        break;
                    case 'global':
                        endpoint = `/api/chunks/global?limit=${this.pageSize}`;
                        break;
                    default:
                        endpoint = `/api/chunks/all?limit=${this.pageSize}`;
                }
                
                const response = await Utils.makeRequest(endpoint);
                
                if (response.success) {
                    this.currentChunks = response.chunks;
                    this.renderChunks();
                } else {
                    throw new Error(response.error || 'Failed to load chunks');
                }
            } catch (error) {
                console.error('Failed to load chunks:', error);
                Utils.showNotification('Failed to load chunks', 'error');
            } finally {
                loadingElement.classList.remove('active');
            }
        }
        
        renderChunks() {
            const container = document.getElementById('chunkList');
            const noChunksElement = document.getElementById('noChunks');
            
            // Clear existing chunks (except loading and no-chunks elements)
            const existingChunks = container.querySelectorAll('.chunk-item');
            existingChunks.forEach(chunk => chunk.remove());
            
            if (this.currentChunks.length === 0) {
                noChunksElement.style.display = 'block';
                return;
            }
            
            noChunksElement.style.display = 'none';
            
            this.currentChunks.forEach(chunk => {
                const chunkElement = this.createChunkElement(chunk);
                container.appendChild(chunkElement);
            });
        }
        
        createChunkElement(chunk) {
            const chunkElement = document.createElement('div');
            chunkElement.className = 'chunk-item';
            chunkElement.dataset.chunkId = chunk.chunk_id;
            
            const contentPreview = Utils.truncateText(chunk.content_preview || chunk.content || '', 200);
            const complexityScore = chunk.complexity_score ? chunk.complexity_score.toFixed(2) : 'N/A';
            const relevanceScore = chunk.relevance_score ? chunk.relevance_score.toFixed(3) : null;
            
            chunkElement.innerHTML = `
                <div class="chunk-header">
                    <label class="chunk-checkbox-label">
                        <input type="checkbox" class="chunk-checkbox" value="${chunk.chunk_id}">
                        <span class="chunk-id">${chunk.chunk_id}</span>
                    </label>
                    <div class="chunk-meta">
                        ${relevanceScore ? `<span class="relevance-score">Relevance: ${relevanceScore}</span>` : `<span class="complexity-score">Score: ${complexityScore}</span>`}
                        <span class="chunk-type">${chunk.chunk_type || 'unknown'}</span>
                        ${this.isSearchMode ? `<span class="search-indicator">🔍</span>` : ''}
                    </div>
                </div>
                <div class="chunk-info">
                    <div class="chunk-source">
                        <strong>Source:</strong> ${chunk.source_document || 'Unknown'}
                        ${chunk.section_path ? `<span class="section-path">${chunk.section_path}</span>` : ''}
                    </div>
                    <div class="chunk-stats">
                        <span>Lines: ${chunk.line_count || 0}</span>
                        <span>Tokens: ${chunk.token_count || 0}</span>
                        <span>Access: ${chunk.access_count || 0}</span>
                    </div>
                </div>
                <div class="chunk-content">
                    ${contentPreview}
                </div>
                <div class="chunk-actions">
                    <button class="btn btn-sm btn-outline view-details" data-chunk-id="${chunk.chunk_id}">
                        View Details
                    </button>
                    <button class="btn btn-sm btn-success approve-single" data-chunk-id="${chunk.chunk_id}">
                        Approve
                    </button>
                    <button class="btn btn-sm btn-danger reject-single" data-chunk-id="${chunk.chunk_id}">
                        Reject
                    </button>
                </div>
            `;
            
            // Bind individual chunk events
            this.bindChunkEvents(chunkElement);
            
            return chunkElement;
        }
        
        bindChunkEvents(chunkElement) {
            // Checkbox selection
            const checkbox = chunkElement.querySelector('.chunk-checkbox');
            checkbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.selectedChunks.add(e.target.value);
                    chunkElement.classList.add('selected');
                } else {
                    this.selectedChunks.delete(e.target.value);
                    chunkElement.classList.remove('selected');
                }
                this.updateSelectionUI();
            });
            
            // View details
            const viewDetailsBtn = chunkElement.querySelector('.view-details');
            viewDetailsBtn.addEventListener('click', (e) => {
                this.viewChunkDetails(e.target.dataset.chunkId);
            });
            
            // Single approve
            const approveBtn = chunkElement.querySelector('.approve-single');
            approveBtn.addEventListener('click', (e) => {
                this.approveSingleChunk(e.target.dataset.chunkId);
            });
            
            // Single reject
            const rejectBtn = chunkElement.querySelector('.reject-single');
            rejectBtn.addEventListener('click', (e) => {
                this.rejectSingleChunk(e.target.dataset.chunkId);
            });
        }
        
        updateSelectionUI() {
            const count = this.selectedChunks.size;
            document.getElementById('selectedCount').textContent = count;
            
            const approveBtn = document.getElementById('approveSelected');
            const pendingBtn = document.getElementById('pendingSelected');
            const rejectBtn = document.getElementById('rejectSelected');
            const promoteBtn = document.getElementById('promoteSelected');
            const demoteBtn = document.getElementById('demoteSelected');
            
            if (count > 0) {
                approveBtn.disabled = false;
                pendingBtn.disabled = false;
                rejectBtn.disabled = false;
                promoteBtn.disabled = false;
                demoteBtn.disabled = false;
            } else {
                approveBtn.disabled = true;
                pendingBtn.disabled = true;
                rejectBtn.disabled = true;
                promoteBtn.disabled = true;
                demoteBtn.disabled = true;
            }
        }
        
        selectAllChunks() {
            const checkboxes = document.querySelectorAll('.chunk-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                this.selectedChunks.add(checkbox.value);
                checkbox.closest('.chunk-item').classList.add('selected');
            });
            this.updateSelectionUI();
        }
        
        clearSelection() {
            const checkboxes = document.querySelectorAll('.chunk-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.closest('.chunk-item').classList.remove('selected');
            });
            this.selectedChunks.clear();
            this.updateSelectionUI();
        }
        
        async approveSelected() {
            if (this.selectedChunks.size === 0) return;
            
            const chunkIds = Array.from(this.selectedChunks);
            
            try {
                const response = await Utils.makeRequest('/api/chunks/approve', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: chunkIds,
                        approved_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification(`Successfully approved ${response.approved_count} chunks`, 'success');
                    this.clearSelection();
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to approve chunks');
                }
            } catch (error) {
                console.error('Failed to approve chunks:', error);
                Utils.showNotification('Failed to approve chunks', 'error');
            }
        }
        
        showRejectionPanel() {
            if (this.selectedChunks.size === 0) return;
            
            document.getElementById('rejectionPanel').style.display = 'block';
            document.getElementById('rejectionReason').focus();
        }
        
        hideRejectionPanel() {
            document.getElementById('rejectionPanel').style.display = 'none';
            document.getElementById('rejectionReason').value = '';
        }
        
        async confirmReject() {
            const reason = document.getElementById('rejectionReason').value.trim();
            if (!reason) {
                Utils.showNotification('Please provide a rejection reason', 'error');
                return;
            }
            
            const chunkIds = Array.from(this.selectedChunks);
            
            try {
                const response = await Utils.makeRequest('/api/chunks/reject', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: chunkIds,
                        rejection_reason: reason,
                        rejected_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification(`Successfully rejected ${response.rejected_count} chunks`, 'success');
                    this.hideRejectionPanel();
                    this.clearSelection();
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to reject chunks');
                }
            } catch (error) {
                console.error('Failed to reject chunks:', error);
                Utils.showNotification('Failed to reject chunks', 'error');
            }
        }
        
        async pendingSelected() {
            if (this.selectedChunks.size === 0) return;
            
            const chunkIds = Array.from(this.selectedChunks);
            
            try {
                const response = await Utils.makeRequest('/api/chunks/set-pending', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: chunkIds,
                        action_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification(`Successfully set ${response.updated_count} chunks to pending`, 'success');
                    this.clearSelection();
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to set chunks to pending');
                }
            } catch (error) {
                console.error('Failed to set chunks to pending:', error);
                Utils.showNotification('Failed to set chunks to pending', 'error');
            }
        }
        
        showPromotionPanel() {
            if (this.selectedChunks.size === 0) return;
            
            document.getElementById('promotionPanel').style.display = 'block';
            document.getElementById('promotionJustification').focus();
        }
        
        hidePromotionPanel() {
            document.getElementById('promotionPanel').style.display = 'none';
            document.getElementById('promotionJustification').value = '';
        }
        
        async confirmPromote() {
            const justification = document.getElementById('promotionJustification').value.trim();
            if (!justification) {
                Utils.showNotification('Please provide a promotion justification', 'error');
                return;
            }
            
            const chunkIds = Array.from(this.selectedChunks);
            
            try {
                const response = await Utils.makeRequest('/api/chunks/bulk-promote', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: chunkIds,
                        justification: justification,
                        action_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification(`Successfully promoted ${response.promoted_count} chunks to Global`, 'success');
                    this.hidePromotionPanel();
                    this.clearSelection();
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to promote chunks');
                }
            } catch (error) {
                console.error('Failed to promote chunks:', error);
                Utils.showNotification('Failed to promote chunks', 'error');
            }
        }
        
        showDemotionPanel() {
            if (this.selectedChunks.size === 0) return;
            
            document.getElementById('demotionPanel').style.display = 'block';
            document.getElementById('demotionJustification').focus();
        }
        
        hideDemotionPanel() {
            document.getElementById('demotionPanel').style.display = 'none';
            document.getElementById('demotionJustification').value = '';
        }
        
        async confirmDemote() {
            const justification = document.getElementById('demotionJustification').value.trim();
            if (!justification) {
                Utils.showNotification('Please provide a demotion justification', 'error');
                return;
            }
            
            const chunkIds = Array.from(this.selectedChunks);
            
            try {
                const response = await Utils.makeRequest('/api/chunks/bulk-demote', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: chunkIds,
                        justification: justification,
                        action_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification(`Successfully demoted ${response.demoted_count} chunks to Project`, 'success');
                    this.hideDemotionPanel();
                    this.clearSelection();
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to demote chunks');
                }
            } catch (error) {
                console.error('Failed to demote chunks:', error);
                Utils.showNotification('Failed to demote chunks', 'error');
            }
        }
        
        async performSearch() {
            const query = document.getElementById('searchQuery').value.trim();
            const searchType = document.getElementById('searchType').value;
            
            if (!query) {
                Utils.showNotification('Please enter a search query', 'error');
                return;
            }
            
            try {
                const response = await Utils.makeRequest('/api/search/unified', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        query: query, 
                        search_type: searchType,
                        limit: this.pageSize 
                    })
                });
                
                if (response.success) {
                    // Enter search mode and display results in main list
                    this.isSearchMode = true;
                    this.currentSearchQuery = query;
                    this.currentSearchType = searchType;
                    this.currentChunks = response.results;
                    
                    // Update UI to show search state
                    this.updateSearchUI(true, query, searchType, response.results.length);
                    this.renderChunks();
                    this.clearSelection();
                    
                    Utils.showNotification(`Found ${response.results.length} results`, 'success');
                } else {
                    throw new Error(response.error || 'Search failed');
                }
            } catch (error) {
                console.error('Search failed:', error);
                Utils.showNotification('Search failed', 'error');
            }
        }
        
        clearSearch() {
            // Exit search mode and return to filtered view
            this.isSearchMode = false;
            this.currentSearchQuery = '';
            document.getElementById('searchQuery').value = '';
            
            // Update UI to hide search state
            this.updateSearchUI(false);
            
            // Reload chunks based on current filter
            this.loadChunks(true);
            this.clearSelection();
            
            Utils.showNotification('Search cleared', 'info');
        }
        
        updateSearchUI(isSearching, query = '', searchType = '', resultCount = 0) {
            const searchStatus = document.getElementById('searchStatus');
            const currentSearchQuery = document.getElementById('currentSearchQuery');
            const clearSearchBtn = document.getElementById('clearSearch');
            const headerElement = document.querySelector('.chunk-display h3');
            
            if (isSearching) {
                searchStatus.style.display = 'block';
                clearSearchBtn.style.display = 'inline-block';
                currentSearchQuery.textContent = `"${query}" (${this.getSearchTypeLabel(searchType)}) - ${resultCount} results`;
                headerElement.textContent = 'Search Results';
                
                // Disable filter clicks during search
                document.querySelectorAll('.clickable-filter').forEach(filter => {
                    filter.style.pointerEvents = 'none';
                    filter.style.opacity = '0.6';
                });
            } else {
                searchStatus.style.display = 'none';
                clearSearchBtn.style.display = 'none';
                
                // Re-enable filter clicks
                document.querySelectorAll('.clickable-filter').forEach(filter => {
                    filter.style.pointerEvents = 'auto';
                    filter.style.opacity = '1';
                });
                
                // Restore header based on current filter
                const filterLabels = {
                    'pending': 'Pending Content',
                    'approved': 'Approved Content', 
                    'rejected': 'Rejected Content',
                    'global': 'Global Content',
                    'all': 'All Content'
                };
                headerElement.textContent = filterLabels[this.currentFilter] || 'Content List';
            }
        }
        
        
        getSearchTypeLabel(searchType) {
            const labels = {
                'simulate': 'Agent Simulation',
                'hybrid': 'Hybrid Search',
                'semantic': 'Semantic Search', 
                'keyword': 'Keyword Search'
            };
            return labels[searchType] || searchType;
        }
        
        async loadRecentActivity() {
            try {
                const response = await Utils.makeRequest('/api/search/recent?limit=5');
                
                if (response.success) {
                    this.displayRecentActivity(response.results);
                } else {
                    throw new Error(response.error || 'Failed to load recent activity');
                }
            } catch (error) {
                console.error('Failed to load recent activity:', error);
                document.getElementById('recentActivity').innerHTML = '<p class="error">Failed to load recent activity</p>';
            }
        }
        
        displayRecentActivity(results) {
            const container = document.getElementById('recentActivity');
            container.innerHTML = '';
            
            if (results.length === 0) {
                container.innerHTML = '<p>No recent activity</p>';
                return;
            }
            
            results.forEach(result => {
                const activityElement = document.createElement('div');
                activityElement.className = 'activity-item';
                activityElement.innerHTML = `
                    <div class="activity-header">
                        <strong>${result.chunk_id}</strong>
                        <span class="activity-time">${Utils.formatDate(result.last_accessed)}</span>
                    </div>
                    <div class="activity-content">${Utils.truncateText(result.content_preview, 80)}</div>
                `;
                container.appendChild(activityElement);
            });
        }
        
        async refreshData() {
            Utils.showNotification('Refreshing data...', 'info');
            await this.loadInitialData();
            this.clearSelection();
            Utils.showNotification('Data refreshed successfully', 'success');
        }
        
        async loadMoreChunks() {
            this.currentPage++;
            await this.loadChunks(false);
        }
        
        startPeriodicRefresh() {
            setInterval(() => {
                this.loadStats();
            }, window.APP_CONFIG.refreshInterval);
        }
        
        async applyFilter(filterType) {
            // Don't allow filter changes during search mode
            if (this.isSearchMode) {
                Utils.showNotification('Clear search first to change filters', 'info');
                return;
            }
            
            // Update active filter UI
            document.querySelectorAll('.clickable-filter').forEach(filter => {
                filter.classList.remove('active');
            });
            document.querySelector(`[data-filter="${filterType}"]`).classList.add('active');
            
            // Update current filter and reload chunks
            this.currentFilter = filterType;
            this.clearSelection();
            await this.loadChunks(true);
            
            // Update header to reflect current filter
            const headerElement = document.querySelector('.chunk-display h3');
            const filterLabels = {
                'pending': 'Pending Content',
                'approved': 'Approved Content', 
                'rejected': 'Rejected Content',
                'global': 'Global Content',
                'all': 'All Content'
            };
            headerElement.textContent = filterLabels[filterType] || 'Content List';
        }
        
        async viewChunkDetails(chunkId) {
            try {
                const response = await Utils.makeRequest(`/api/chunks/${chunkId}/context`);
                
                if (response.success) {
                    this.showChunkModal(response.data);
                } else {
                    throw new Error(response.error || 'Failed to load chunk details');
                }
            } catch (error) {
                console.error('Failed to load chunk details:', error);
                Utils.showNotification('Failed to load chunk details', 'error');
            }
        }
        
        showChunkModal(data) {
            const modal = document.getElementById('chunkModal');
            const modalBody = document.getElementById('modalBody');
            
            const chunk = data.chunk;
            
            modalBody.innerHTML = `
                <div class="chunk-details">
                    <h4>Chunk Information</h4>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <label>ID:</label>
                            <span>${chunk.chunk_id}</span>
                        </div>
                        <div class="detail-item">
                            <label>Realm:</label>
                            <span>${chunk.realm_id}</span>
                        </div>
                        <div class="detail-item">
                            <label>Type:</label>
                            <span>${chunk.chunk_type}</span>
                        </div>
                        <div class="detail-item">
                            <label>Status:</label>
                            <span class="status-${chunk.approval_status}">${chunk.approval_status}</span>
                        </div>
                        <div class="detail-item">
                            <label>Source:</label>
                            <span>${chunk.source_document}</span>
                        </div>
                        <div class="detail-item">
                            <label>Created:</label>
                            <span>${Utils.formatDate(chunk.created_at)}</span>
                        </div>
                    </div>
                    
                    <h4>Content</h4>
                    <div class="chunk-content-full">
                        <pre>${chunk.content}</pre>
                    </div>
                    
                    ${data.context_chunks && data.context_chunks.length > 0 ? `
                        <h4>Related Chunks</h4>
                        <div class="context-chunks">
                            ${data.context_chunks.map(ctx => `
                                <div class="context-chunk">
                                    <strong>${ctx.chunk_id}</strong> - ${ctx.chunk_type}
                                    <div class="context-preview">${Utils.truncateText(ctx.content, 100)}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div class="chunk-actions-modal">
                        <h4>Chunk Actions</h4>
                        <div class="modal-action-buttons">
                            <button class="btn btn-success toggle-approval" data-chunk-id="${chunk.chunk_id}" data-current-status="${chunk.approval_status}">
                                ${chunk.approval_status === 'approved' ? 'Mark as Pending' : 'Mark as Approved'}
                            </button>
                            <button class="btn btn-primary toggle-realm" data-chunk-id="${chunk.chunk_id}" data-current-realm="${chunk.realm_id}">
                                ${chunk.realm_id === 'GLOBAL' ? 'Demote to Project' : 'Promote to Global'}
                            </button>
                            <button class="btn btn-danger delete-chunk" data-chunk-id="${chunk.chunk_id}">
                                Delete Chunk
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Bind modal action events
            this.bindModalActions();
            
            modal.style.display = 'block';
        }
        
        closeModal() {
            document.getElementById('chunkModal').style.display = 'none';
        }
        
        bindModalActions() {
            // Toggle approval status
            const toggleApprovalBtn = document.querySelector('.toggle-approval');
            if (toggleApprovalBtn) {
                toggleApprovalBtn.addEventListener('click', async (e) => {
                    const chunkId = e.target.dataset.chunkId;
                    const currentStatus = e.target.dataset.currentStatus;
                    
                    try {
                        const response = await Utils.makeRequest(`/api/chunks/${chunkId}/toggle-approval`, {
                            method: 'POST',
                            body: JSON.stringify({
                                action_by: 'frontend_user',
                                reason: `Status toggled from ${currentStatus} via modal`
                            })
                        });
                        
                        if (response.success) {
                            Utils.showNotification(response.message, 'success');
                            this.closeModal();
                            await this.refreshData();
                        } else {
                            throw new Error(response.error || 'Failed to toggle approval status');
                        }
                    } catch (error) {
                        console.error('Failed to toggle approval:', error);
                        Utils.showNotification('Failed to toggle approval status', 'error');
                    }
                });
            }
            
            // Toggle realm (promote/demote)
            const toggleRealmBtn = document.querySelector('.toggle-realm');
            if (toggleRealmBtn) {
                toggleRealmBtn.addEventListener('click', async (e) => {
                    const chunkId = e.target.dataset.chunkId;
                    const currentRealm = e.target.dataset.currentRealm;
                    
                    const isGlobal = currentRealm === 'GLOBAL';
                    const actionText = isGlobal ? 'demoting from GLOBAL to project' : 'promoting to GLOBAL';
                    const promptText = isGlobal ? 
                        'Enter justification for demoting to project realm:' : 
                        'Enter justification for promoting to GLOBAL realm:';
                    
                    const justification = prompt(promptText);
                    if (!justification) return;
                    
                    try {
                        const response = await Utils.makeRequest(`/api/chunks/${chunkId}/toggle-realm`, {
                            method: 'POST',
                            body: JSON.stringify({
                                justification: justification,
                                action_by: 'frontend_user'
                            })
                        });
                        
                        if (response.success) {
                            Utils.showNotification(response.message, 'success');
                            this.closeModal();
                            await this.refreshData();
                        } else {
                            throw new Error(response.error || `Failed ${actionText}`);
                        }
                    } catch (error) {
                        console.error(`Failed ${actionText}:`, error);
                        Utils.showNotification(`Failed ${actionText}`, 'error');
                    }
                });
            }
            
            // Delete chunk
            const deleteBtn = document.querySelector('.delete-chunk');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', async (e) => {
                    const chunkId = e.target.dataset.chunkId;
                    
                    const confirmed = confirm(`Are you sure you want to delete chunk ${chunkId}? This action cannot be undone.`);
                    if (!confirmed) return;
                    
                    const reason = prompt('Enter reason for deletion:');
                    if (!reason) return;
                    
                    try {
                        const response = await Utils.makeRequest(`/api/chunks/${chunkId}/delete`, {
                            method: 'DELETE',
                            body: JSON.stringify({
                                deleted_by: 'frontend_user',
                                reason: reason
                            })
                        });
                        
                        if (response.success) {
                            Utils.showNotification(response.message, 'success');
                            this.closeModal();
                            await this.refreshData();
                        } else {
                            throw new Error(response.error || 'Failed to delete chunk');
                        }
                    } catch (error) {
                        console.error('Failed to delete chunk:', error);
                        Utils.showNotification('Failed to delete chunk', 'error');
                    }
                });
            }
        }
        
        async approveSingleChunk(chunkId) {
            try {
                const response = await Utils.makeRequest('/api/chunks/approve', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: [chunkId],
                        approved_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification('Chunk approved successfully', 'success');
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to approve chunk');
                }
            } catch (error) {
                console.error('Failed to approve chunk:', error);
                Utils.showNotification('Failed to approve chunk', 'error');
            }
        }
        
        async rejectSingleChunk(chunkId) {
            const reason = prompt('Enter rejection reason:');
            if (!reason) return;
            
            try {
                const response = await Utils.makeRequest('/api/chunks/reject', {
                    method: 'POST',
                    body: JSON.stringify({
                        chunk_ids: [chunkId],
                        rejection_reason: reason,
                        rejected_by: 'frontend_user'
                    })
                });
                
                if (response.success) {
                    Utils.showNotification('Chunk rejected successfully', 'success');
                    await this.refreshData();
                } else {
                    throw new Error(response.error || 'Failed to reject chunk');
                }
            } catch (error) {
                console.error('Failed to reject chunk:', error);
                Utils.showNotification('Failed to reject chunk', 'error');
            }
        }
    }
    
    // Initialize the application when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        new ChunkReviewApp();
    });
</script>
{% endblock %}